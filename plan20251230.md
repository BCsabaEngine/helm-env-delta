# Transform Files & Stop Rules File Support

## Overview

Add support for loading transform rules and stop rules from external YAML files, complementing the existing inline regex find/replace patterns. Maintains backward compatibility while enabling cleaner configuration management.

## User Requirements

1. **Transform Files:**
   - YAML format with simple key:value pairs (literal string replacement)
   - Separate files for content transforms vs filename transforms
   - User manually specifies file paths in config.yaml (no auto-lookup)
   - `contentFile` and `filenameFile` accept either:
     - Single string (one file): `contentFile: './transforms/common.yaml'`
     - Array of strings (multiple files): `contentFile: ['./common.yaml', './uat-to-prod.yaml']`
   - Complements existing regex find/replace
   - Case-insensitive matching available via regex `/i` flag (no separate option needed)

2. **Stop Rules from Files:**
   - Two new stop rule types: `regexFile` and `regexFileKey`
   - Work exactly like existing `regex` stop rule (blocks if value matches pattern)
   - `regexFile`: Loads array of regex patterns from file (must be YAML array)
   - `regexFileKey`: Uses keys from transform file as regex patterns (must be YAML object with keys)
   - Each pattern in file becomes a separate regex validation (OR logic)

3. **Optional Path for Regex Stop Rules:**
   - ALL three regex rules (`regex`, `regexFile`, `regexFileKey`) now have OPTIONAL path
   - **Path set:** Check value at specific JSONPath (targeted mode, current behavior)
   - **Path NOT set:** Recursively scan ALL values in entire YAML file (global mode)
   - Global mode fails if ANY value anywhere matches the pattern
   - Useful for blocking forbidden values globally (e.g., 'localhost', 'debug-mode', 'test-')

4. **Error Handling:**
   - Missing files: Fail immediately with error
   - Duplicate keys across files: Silent (last file wins)
   - Invalid file format: regexFile must be array, regexFileKey must be object with keys

## File Formats

### Transform File (YAML key:value)
```yaml
# transforms/content/uat-to-prod.yaml
uat-cluster: prod-cluster
uat.internal.example.com: prod.internal.example.com
dev-database: prod-database
```

### Forbidden Patterns File (YAML array)
```yaml
# patterns/forbidden.yaml
# Array of regex patterns to block
- '^v0\.'           # Block pre-release versions
- 'localhost'       # Block localhost references
- '.*-debug$'       # Block debug suffixes
- 'test-.*'         # Block test prefixes
```

### Config Schema Extension
```yaml
transforms:
  '**/*.yaml':
    # NEW: File-based transforms (applied FIRST)
    # Can be single string or array of strings
    contentFile:
      - './transforms/content/common.yaml'
      - './transforms/content/uat-to-prod.yaml'
    # Or single file:
    # contentFile: './transforms/content/uat-to-prod.yaml'

    filenameFile: './transforms/filename/path-renames.yaml'

    # Existing inline regex (applied AFTER file-based)
    content:
      - find: 'v(\d+)\.(\d+)\.(\d+)-uat'
        replace: 'v$1.$2.$3-prod'
    filename:
      - find: 'deployment-uat\.yaml'
        replace: 'deployment-prod.yaml'

stopRules:
  '**/*.yaml':
    # Existing inline rules
    - type: 'semverMajorUpgrade'
      path: 'image.tag'

    # NEW: Block values matching patterns from array file (targeted)
    - type: 'regexFile'
      path: 'version'
      file: './patterns/forbidden.yaml'

    # NEW: Block ANY value matching patterns (global scan)
    - type: 'regexFile'
      # path omitted - scans all values recursively
      file: './patterns/forbidden-global.yaml'

    # NEW: Block values matching keys from transform file (targeted)
    - type: 'regexFileKey'
      path: 'database.url'
      file: './transforms/content/uat-to-prod.yaml'

    # Existing regex rule also supports pathless mode
    - type: 'regex'
      regex: '^127\.'  # Block localhost IPs anywhere in file
```

## Implementation Plan

### Phase 1: Schema Changes (src/configFile.ts)

**Location:** Lines 104-141 (transformRulesSchema)

1. Add new Zod schemas:
   ```typescript
   const transformFileEntrySchema = z.record(z.string(), z.string());
   ```

2. Update `transformRulesSchema`:
   ```typescript
   .object({
     content: z.array(transformRuleSchema).optional(),
     filename: z.array(transformRuleSchema).optional(),
     // Accept either single string or array of strings
     contentFile: z.union([
       z.string().min(1),
       z.array(z.string().min(1))
     ]).optional(),
     filenameFile: z.union([
       z.string().min(1),
       z.array(z.string().min(1))
     ]).optional()
   })
   .refine(
     (data) =>
       data.content !== undefined ||
       data.filename !== undefined ||
       data.contentFile !== undefined ||
       data.filenameFile !== undefined,
     { message: 'At least one transform type must be specified' }
   );
   ```

3. Update existing `regex` stop rule schema (make path optional):
   ```typescript
   z.object({
     type: z.literal('regex'),
     path: z.string().min(1).optional(),  // CHANGED: now optional
     regex: z.string().min(1)
   })
   .refine(/* validate regex compiles */)
   ```

4. Add new stop rule types (add to discriminated union in stopRuleSchema):
   ```typescript
   // Load regex patterns from array file
   z.object({
     type: z.literal('regexFile'),
     path: z.string().min(1).optional(),  // Optional: targeted or global
     file: z.string().min(1)
   }),

   // Load regex patterns from transform file keys
   z.object({
     type: z.literal('regexFileKey'),
     path: z.string().min(1).optional(),  // Optional: targeted or global
     file: z.string().min(1)
   })
   ```

### Phase 2: File Loaders

#### Create `src/utils/transformFileLoader.ts` (new file)

**Functions:**
- `loadTransformFile(filePath, configDirectory)` - Loads single file
- `loadTransformFiles(filePaths, configDirectory)` - Loads multiple files
- `escapeRegex(string)` - Escapes regex special characters for literal matching

**Features:**
- Reads YAML files (Record<string, string>)
- Validates format (flat key:value only, no nested objects)
- Converts to find/replace array with escaped regex patterns (literal matching)
- Error handling: file not found, parse errors, invalid format

**Error class:** `TransformFileLoaderError` with codes:
- `FILE_NOT_FOUND` / `ENOENT`
- `PARSE_ERROR`
- `INVALID_FORMAT`

#### Create `src/utils/regexPatternFileLoader.ts` (new file)

**Functions:**
- `loadRegexPatternArray(filePath, configDirectory)` - Loads array of regex patterns
- `loadRegexPatternsFromKeys(filePath, configDirectory)` - Loads transform file, returns keys as patterns

**Features:**
- Reads YAML files
- **`loadRegexPatternArray`:** Validates file is array, validates each pattern compiles
- **`loadRegexPatternsFromKeys`:** Validates file is object with keys, extracts keys as patterns
- Returns array of regex pattern strings
- Error handling: file not found, parse errors, invalid format, invalid regex

**Error class:** `RegexPatternFileLoaderError` with codes:
- `FILE_NOT_FOUND` / `ENOENT`
- `PARSE_ERROR`
- `INVALID_FORMAT_NOT_ARRAY` (regexFile must be array)
- `INVALID_FORMAT_NOT_OBJECT` (regexFileKey must be object)
- `INVALID_REGEX`

### Phase 3: Config Loading Integration

#### Update `src/configLoader.ts`

**Location:** Lines 8-22 (loadConfigFile function)

1. Add new function:
   - `expandTransformFiles(config, configDirectory)` - Loads transform files and merges into inline rules

2. Update `loadConfigFile`:
   ```typescript
   export const loadConfigFile = (...): FinalConfig => {
     const configDirectory = path.dirname(path.resolve(configPath));
     const mergedConfig = resolveConfigWithExtends(configPath, new Set(), 0, logger);

     // Expand file-based transform configs
     const expandedConfig = expandTransformFiles(mergedConfig, configDirectory);

     const config = parseFinalConfig(expandedConfig, configPath);
     // ... rest unchanged
   };
   ```

3. **`expandTransformFiles` implementation:**
   ```typescript
   const expandTransformFiles = (config: BaseConfig, configDirectory: string): BaseConfig => {
     if (!config.transforms) return config;

     const expandedTransforms: TransformConfig = {};

     for (const [pattern, rules] of Object.entries(config.transforms)) {
       const expanded: TransformRules = {
         content: [...(rules.content ?? [])],
         filename: [...(rules.filename ?? [])]
       };

       // Load and prepend content transform files
       if (rules.contentFile) {
         // Normalize to array (handle both string and array input)
         const filePaths = Array.isArray(rules.contentFile)
           ? rules.contentFile
           : [rules.contentFile];
         const fileEntries = loadTransformFiles(filePaths, configDirectory);
         expanded.content = [...fileEntries, ...expanded.content];
       }

       // Load and prepend filename transform files
       if (rules.filenameFile) {
         // Normalize to array (handle both string and array input)
         const filePaths = Array.isArray(rules.filenameFile)
           ? rules.filenameFile
           : [rules.filenameFile];
         const fileEntries = loadTransformFiles(filePaths, configDirectory);
         expanded.filename = [...fileEntries, ...expanded.filename];
       }

       expandedTransforms[pattern] = expanded;
     }

     return { ...config, transforms: expandedTransforms };
   };
   ```

**Execution order for transforms:**
1. Load transform files → convert to find/replace entries with escaped regex (literal matching)
2. Prepend file-based entries before inline regex rules
3. Apply all transforms sequentially (file-based literal replacements first, then regex patterns)

**Note:** Stop rules are NOT expanded in configLoader - they're loaded on-demand during validation

#### Update `src/configMerger.ts`

**Location:** Lines 110-138 (mergeTransformRules)

1. Update `mergeTransformRules` to merge file arrays:
   ```typescript
   const mergeTransformRules = (parent?, child?): TransformRules => {
     // Helper to normalize string | string[] to string[]
     const normalizeToArray = (value: string | string[] | undefined): string[] => {
       if (!value) return [];
       return Array.isArray(value) ? value : [value];
     };

     return {
       content: [...(parent?.content ?? []), ...(child?.content ?? [])],
       filename: [...(parent?.filename ?? []), ...(child?.filename ?? [])],
       contentFile: [
         ...normalizeToArray(parent?.contentFile),
         ...normalizeToArray(child?.contentFile)
       ],
       filenameFile: [
         ...normalizeToArray(parent?.filenameFile),
         ...normalizeToArray(child?.filenameFile)
       ]
     };
   };
   ```

   Note: Merged result is always an array, even if inputs were strings.

### Phase 4: Stop Rules Validator Extension

#### Update `src/stopRulesValidator.ts`

Update validation functions to support optional path:

1. **Update `validateRegexRule(rule, oldData, updatedData)`**
   - **If path is set:** Extract value at path, test against pattern (current behavior)
   - **If path is NOT set:** Recursively scan all values in updatedData (or oldData if undefined)
   - Return violation if ANY value matches pattern
   - Add helper: `getAllValuesRecursive(data)` - flattens all values from nested YAML

2. **Add `validateRegexFileRule(rule, oldData, updatedData, configDirectory)`**
   - Load patterns from array file using `loadRegexPatternArray()`
   - **If path is set:** Extract value at path, test against all patterns
   - **If path is NOT set:** Get all values recursively, test against all patterns
   - Return violation if ANY pattern matches ANY value
   - Same logic as `regex` rule, just patterns from file

3. **Add `validateRegexFileKeyRule(rule, oldData, updatedData, configDirectory)`**
   - Load transform file keys using `loadRegexPatternsFromKeys()`
   - **If path is set:** Extract value at path, test against all key patterns
   - **If path is NOT set:** Get all values recursively, test against all key patterns
   - Return violation if ANY pattern matches ANY value
   - Same logic as `regex` rule, patterns are the transform file keys

4. **Update `validateStopRule()` dispatcher:**
   - Add cases for `'regexFile'` and `'regexFileKey'`
   - Pass `configDirectory` through the call chain (needed for file loading)
   - **BREAKING:** Change signature to pass full data objects, not just extracted values
     - Old: `validateStopRule(rule, oldValue, updatedValue)`
     - New: `validateStopRule(rule, oldData, updatedData, configDirectory)`

5. **Add helper `getAllValuesRecursive(data)`:**
   - Recursively traverses YAML structure
   - Returns array of all leaf values (strings, numbers, booleans)
   - Skips keys, only collects values
   - Handles nested objects, arrays

**Note:** Files are loaded during validation, not during config loading. This keeps stop rules lazy and avoids expanding during config merge.

### Phase 5: Testing

#### Unit Tests (new files)

1. **test/utils/transformFileLoader.test.ts**
   - Load valid transform file (key:value pairs)
   - Handle missing file (ENOENT)
   - Handle invalid YAML syntax
   - Handle invalid format (array, nested objects, non-string values)
   - Regex escaping (dots, brackets, special chars) for literal matching
   - Multiple files (duplicate keys = last wins)

2. **test/utils/regexPatternFileLoader.test.ts**
   - Load valid pattern array file
   - Load valid transform file (extract keys)
   - Handle missing file, parse errors
   - **Handle invalid format (regexFile not array - must error)**
   - **Handle invalid format (regexFileKey not object - must error)**
   - Validate regex patterns (invalid regex should error)
   - Empty files (array: [], object: {}) return empty array

#### Integration Tests (new files)

3. **test/integration/transformFiles.test.ts**
   - End-to-end: content transform file (single string)
   - End-to-end: content transform files (array)
   - End-to-end: filename transform file (single string)
   - End-to-end: filename transform files (array)
   - Combined: inline regex + file-based transforms
   - Multiple files loaded in order
   - Case-insensitive matching using /i flag in inline regex

4. **test/integration/regexFileStopRules.test.ts**
   - End-to-end: regexFile stop rule (with path)
   - End-to-end: regexFile stop rule (without path - global scan)
   - End-to-end: regexFileKey stop rule (with path)
   - End-to-end: regexFileKey stop rule (without path - global scan)
   - Violations detected correctly (value matches pattern)
   - Multiple patterns (OR logic - any match fails)
   - Combined: inline regex + regexFile + regexFileKey
   - Nested values detected in pathless mode

#### Updated Tests

5. **test/configFile.test.ts** - Validate new schema fields:
   - contentFile as string (single file)
   - contentFile as array (multiple files)
   - filenameFile as string (single file)
   - filenameFile as array (multiple files)
   - regexFile, regexFileKey types
6. **test/configMerger.test.ts** - Merge contentFile/filenameFile:
   - Parent string + child string → merged array
   - Parent array + child string → merged array
   - Parent string + child array → merged array
   - Parent array + child array → merged array
7. **test/configLoader.test.ts** - Integration with file loading
8. **test/stopRulesValidator.test.ts** - Add tests for:
   - regexFile and regexFileKey validation (with path)
   - regexFile and regexFileKey validation (without path - global)
   - regex rule with optional path (backward compatibility + new pathless mode)
   - getAllValuesRecursive helper (nested objects, arrays, primitives)
9. **test/perf/transformer.perf.test.ts** - Performance impact (should be minimal)

### Phase 6: Documentation

1. **CLAUDE.md** - Add section on transform files and regexFile/regexFileKey stop rules
2. **example/5-transform-files/** - New example directory with:
   - config.yaml (demonstrates contentFile, filenameFile, regexFile, regexFileKey with pathless mode)
   - transforms/content/common.yaml
   - transforms/content/uat-to-prod.yaml
   - transforms/filename/path-renames.yaml
   - patterns/forbidden.yaml (array of regex patterns)
   - patterns/forbidden-global.yaml (for pathless regexFile example)
   - source/ and destination/ samples
   - README.md
3. **src/commandLine.ts** - Update help text with examples

### Phase 7: Error Handling

**Error messages should include:**
- Clear error message
- Error code
- File path (both relative and resolved absolute)
- Hints for resolution
- Examples when helpful

**Edge cases:**
- Empty transform file → Return empty array, no error
- Empty pattern file (array: [], object: {}) → Return empty array, validates nothing (no error)
- Duplicate keys across transform files → Silent (last file wins)
- Transform file references non-existent file → Error with hint
- Pattern file references non-existent file → Error with hint
- Transform file contains nested objects → Error: must be flat key:value
- **regexFile not array → Error: "File must contain YAML array of patterns"**
- **regexFileKey not object → Error: "File must contain YAML object with keys"**
- Invalid regex pattern in file → Error with pattern and line number
- Pathless regex rule on file with no values → No violation (nothing to check)
- Pathless regex rule with deeply nested values → Recursively scans all
- Relative paths → Resolve relative to config file directory
- Absolute paths → Support directly

## Critical Files to Modify

1. **src/configFile.ts** (lines 104-141, 171) - Schema changes
2. **src/configLoader.ts** (lines 8-22) - Integration point for file loading
3. **src/configMerger.ts** (lines 110-138) - Merge file arrays
4. **src/utils/transformFileLoader.ts** (NEW) - Transform file loading
5. **src/utils/regexPatternFileLoader.ts** (NEW) - Pattern file loading for stop rules
6. **src/stopRulesValidator.ts** - Update regex validation + add regexFile and regexFileKey
   - Make path optional on regex rule
   - Add getAllValuesRecursive helper
   - Update validateStopRule signature (pass full data + configDirectory)

## Key Design Decisions

1. **Execution Order:** File-based transforms (literal) applied BEFORE inline regex
2. **Literal Matching:** Transform file keys are escaped for regex safety (always literal, case-sensitive)
3. **Case-Insensitive Matching:** Available via regex `/i` flag in inline transforms (no separate option needed)
4. **Error Handling:** Missing files fail immediately (no silent failures)
5. **Duplicate Keys:** Last file wins (silent override)
6. **Backward Compatibility:** All new fields optional, existing configs work unchanged
7. **Path Resolution:** Relative paths resolved from config file directory
8. **Flexible File Syntax:** contentFile/filenameFile accept both single string and array for convenience
9. **Stop Rule Files Loaded On-Demand:** regexFile/regexFileKey load patterns during validation (not during config loading)
10. **Pattern Matching Logic:** Each pattern in file is tested independently (OR logic - any match causes violation)
11. **Same Behavior as regex Rule:** regexFile/regexFileKey work identically to existing `regex` stop rule, just patterns come from files
12. **Optional Path Modes:**
    - **Targeted mode (path set):** Check specific field value at JSONPath
    - **Global mode (path not set):** Recursively scan ALL values in entire YAML file
13. **Recursive Value Scanning:** When path is not set, extracts all leaf values from nested structures (objects, arrays)
14. **File Format Validation:** regexFile MUST be array (error if not), regexFileKey MUST be object with keys (error if not)

## Performance Considerations

- File I/O during config loading (acceptable, happens once at startup)
- Transform processing identical to existing regex transforms
- Minimal memory overhead (file entries loaded once)
- No caching needed (config loaded once per run)

## Migration Path

Users can gradually adopt:
1. Keep existing inline transforms (no changes required)
2. Extract common patterns to files (add contentFiles alongside content)
3. Reference files in config (both inline and file-based work together)
4. Eventually migrate fully to files (optional)
